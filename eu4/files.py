import ClauseWizard as cw
import csv
import json

from typing import Any

type Item = Value | list[Value] | Scope
type Value = str | int | float | bool

# Contains generic classes which can be extended to represent specific types of files
# They can also be used as-is to represent files "anonymously"


# An ordered list of key-item pairs where keys do not have to be unique
class Scope:
    scope: list[tuple[str, Item]]
    def __init__(self):
        self.scope = []
    
    def __iter__(self):
        return iter(self.scope)
    
    def __getitem__(self, key: str) -> Any:
        result = self.getAll(key)
        if len(result) == 1:
            return result[0]
        if len(result) > 1:
            raise ValueError(f"Duplicate key, use iteration: {key}")
        raise KeyError(f"Key not found: {key}")
    
    def __contains__(self, key: str) -> bool:
        return any(k == key for k, _ in self)
    
    def get(self, key: str, default: Any) -> Any:
        result = self.getAll(key)
        return result[-1] if result else default
    
    def getAll(self, key: str) -> list[Any]:
        return [v for k, v in self if k == key]

    def append(self, key: str, item: Item):
        self.scope.append((key, item))

# Generic scope file object
class ScopeFile:
    scope: Scope
    def __init__(self, path: str):
        with open(path, 'r', encoding="cp1252") as file:
            text = file.read()
        try:
            tokens = cw.cwparse(text)
        # If the parsing fails, ClauseWizard raises a pyparsing.exceptions.ParseException.
        # We catch it and raise a ValueError with a more informative message.
        except Exception as parseException:
            raise ValueError(f"Failed to parse scope file '{path}'") from parseException
        self.scope = _parseTokens(tokens)

# Parse the tokens generated by cw.cwparse into a Scope
def _parseTokens(tokens: list[tuple[str, list]]) -> Scope:
    scope = Scope()
    # Item tokens can either be:
    # - a constant (singleton list of a value)
    # - an array (list of singleton lists of values)
    # - a scope (list of string-list pairs)
    # Values can be strings, ints, floats or booleans
    for key, item in tokens:
        # constant
        if not isinstance(item[0], list):
            scope.append(key, item[0])
        # array
        elif len(item[0]) == 1:
            scope.append(key, [subitem[0] for subitem in item])
        # scope
        elif len(item[0]) == 2:
            scope.append(key, _parseTokens(item))
        # invalid
        else:
            raise ValueError(f"Invalid item: {item}")
    return scope


class JsonFile:
    json: dict
    def __init__(self, path: str):
        with open(path, 'r') as file:
            self.json = json.load(file)
        
    def __getitem__(self, key: str) -> Any:
        return self.json[key]


class CsvFile:
    csv: list[list[str]]
    def __init__(self, path: str):
        with open(path, 'r', encoding="cp1252") as file:
            self.csv = [row for row in csv.reader(file, delimiter=';', quotechar=None)]
        self.csv.pop(0)
    
    def __iter__(self):
        return iter(self.csv)
